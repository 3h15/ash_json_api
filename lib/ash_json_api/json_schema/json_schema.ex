defmodule AshJsonApi.JsonSchema do
  def generate(api) do
    resources =
      api
      |> Ash.resources()
      |> Enum.filter(&(AshJsonApi.JsonApiResource in &1.mix_ins()))

    route_schemas =
      Enum.flat_map(resources, fn resource ->
        resource
        |> AshJsonApi.routes()
        |> Enum.map(&route_schema(&1, api, resource))
      end)

    schema_id = "autogenerated_ash_json_api_schema"

    routes =
      if AshJsonApi.serve_schema(api) do
        [schema_schema(api, schema_id) | route_schemas]
      end

    definitions =
      Enum.reduce(resources, base_definitions(), fn resource, acc ->
        Map.put(acc, Ash.type(resource), resource_object_schema(resource))
      end)

    %{
      "$schema" => "http://json-schema.org/draft-06/schema#",
      "$id" => schema_id,
      "definitions" => definitions,
      "links" => routes
    }
  end

  # This is for our representation of a resource *in the response*
  def resource_object_schema(resource) do
    %{
      "description" => "A \"Resource object\" representing a #{Ash.type(resource)}",
      "type" => "object",
      "required" => ["type", "id"],
      "properties" => %{
        "type" => %{
          "type" => "string"
        },
        "id" => %{
          "type" => "string"
        },
        "attributes" => attributes(resource),
        "relationships" => relationships(resource)
        # "meta" => %{
        #   "$ref" => "#/definitions/meta"
        # }
      },
      "additionalProperties" => false
    }
  end

  defp schema_schema(api, schema_id) do
    href = Path.join(AshJsonApi.prefix(api) || "", "/schema")

    %{
      "href" => href,
      "method" => "GET",
      "rel" => "self",
      "targetSchema" => %{
        "$ref" => schema_id
      }
    }
  end

  defp base_definitions() do
    %{
      "links" => %{
        "type" => "object",
        "additionalProperties" => %{
          "$ref" => "#/definitions/link"
        }
      },
      "link" => %{
        "description" =>
          "A link **MUST** be represented as either: a string containing the link's URL or a link object.",
        "type" => "string"
      },
      "errors" => %{
        "type" => "array",
        "items" => %{
          "$ref" => "#/definitions/error"
        },
        "uniqueItems" => true
      },
      "error" => %{
        "type" => "object",
        "properties" => %{
          "id" => %{
            "description" => "A unique identifier for this particular occurrence of the problem.",
            "type" => "string"
          },
          "links" => %{
            "$ref" => "#/definitions/links"
          },
          "status" => %{
            "description" =>
              "The HTTP status code applicable to this problem, expressed as a string value.",
            "type" => "string"
          },
          "code" => %{
            "description" => "An application-specific error code, expressed as a string value.",
            "type" => "string"
          },
          "title" => %{
            "description" =>
              "A short, human-readable summary of the problem. It **SHOULD NOT** change from occurrence to occurrence of the problem, except for purposes of localization.",
            "type" => "string"
          },
          "detail" => %{
            "description" =>
              "A human-readable explanation specific to this occurrence of the problem.",
            "type" => "string"
          },
          "source" => %{
            "type" => "object",
            "properties" => %{
              "pointer" => %{
                "description" =>
                  "A JSON Pointer [RFC6901] to the associated entity in the request document [e.g. \"/data\" for a primary data object, or \"/data/attributes/title\" for a specific attribute].",
                "type" => "string"
              },
              "parameter" => %{
                "description" => "A string indicating which query parameter caused the error.",
                "type" => "string"
              }
            }
          },
          "meta" => %{
            "$ref" => "#/definitions/meta"
          }
        },
        "additionalProperties" => false
      }
    }
  end

  defp attributes(resource) do
    %{
      "description" => "An attributes object for a #{Ash.type(resource)}",
      "type" => "object",
      "properties" => resource_attributes(resource),
      "additionalProperties" => false
    }
  end

  defp resource_attributes(resource) do
    resource
    |> AshJsonApi.fields()
    |> Enum.reduce(%{}, fn field, acc ->
      attr = Ash.attribute(resource, field)

      if attr do
        Map.put(acc, to_string(field), resource_field_type(resource, attr))
      else
        acc
      end
    end)
  end

  defp relationships(resource) do
    %{
      "description" => "A relationships object for a #{Ash.type(resource)}",
      "type" => "object",
      "properties" => resource_relationships(resource),
      "additionalProperties" => false
    }
  end

  defp resource_relationships(resource) do
    resource
    |> AshJsonApi.fields()
    |> Enum.reduce(%{}, fn field, acc ->
      rel = Ash.relationship(resource, field)

      if rel do
        data = resource_relationship_field_data(resource, rel)
        links = resource_relationship_link_data(resource, rel)

        object =
          if links do
            %{"data" => data, "links" => links}
          else
            %{"data" => data}
          end

        Map.put(
          acc,
          to_string(field),
          object
        )
      else
        acc
      end
    end)
  end

  defp resource_relationship_link_data(resource, rel) do
    # TODO: link to relationships when those routes are available
    nil
  end

  # TODO: When links are set up again, add those
  defp resource_relationship_field_data(_resource, %{
         cardinality: :one,
         destination: destination
       }) do
    %{
      "description" => "References to the related #{Ash.type(destination)}",
      anyOf: [
        %{
          "type" => "null"
        },
        %{
          "description" => "Resource identifiers of the related #{Ash.type(destination)}",
          "type" => "object",
          "required" => ["type", "id"],
          "properties" => %{
            "type" => %{"enum" => Ash.type(destination)},
            "id" => %{"type" => "string"}
            # TODO: support meta here.
          }
        }
      ]
    }
  end

  defp resource_relationship_field_data(_resource, %{
         cardinality: :many,
         destination: destination
       }) do
    %{
      "description" => "An array of references to the related #{Ash.type(destination)}",
      "type" => "array",
      "items" => %{
        "description" => "Resource identifiers of the related #{Ash.type(destination)}",
        "type" => "object",
        "required" => ["type", "id"],
        "properties" => %{
          "type" => %{"enum" => Ash.type(destination)},
          "id" => %{"type" => "string"}
          # TODO: support meta here.
        }
      },
      "uniqueItems" => true
    }
  end

  defp resource_field_type(_resource, %{type: :string}) do
    %{
      "type" => "string"
    }
  end

  defp resource_field_type(_, %{type: type}) do
    raise "unimplemented type #{type}"
  end

  defp route_schema(%{method: method} = route, api, resource) when method in [:delete, :get] do
    href = route_href(route, api)

    %{
      "href" => href,
      "description" => "pending",
      "method" => route.method |> to_string() |> String.upcase(),
      "rel" => to_string(route.type),
      "targetSchema" => target_schema(route, api, resource)
    }
  end

  defp route_schema(route, api, resource) do
    href = route_href(route, api)

    %{
      "href" => href,
      "description" => "pending",
      "method" => route.method |> to_string() |> String.upcase(),
      "rel" => to_string(route.type),
      "schema" => route_in_schema(route, api, resource),
      "targetSchema" => target_schema(route, api, resource)
    }
  end

  defp route_in_schema(%{type: type}, api, resource) when type in [:index, :get, :delete] do
    %{}
  end

  defp route_in_schema(%{type: type} = route, api, resource) when type in [:create] do
    raise "support create!"
  end

  defp route_in_schema(%{type: type}, _, _) do
    raise "#{type} not supported yet!"
  end

  defp target_schema(route, _api, resource) do
    case route.type do
      :index ->
        %{
          "oneOf" => [
            %{
              "data" => %{
                "description" =>
                  "An array of resource objects representing a #{Ash.type(resource)}",
                "type" => "array",
                "items" => %{
                  "$ref" => "#/definitions/#{Ash.type(resource)}"
                },
                "uniqueItems" => true
              }
            },
            %{
              "$ref" => "#/definitions/errors"
            }
          ]
        }

      _ ->
        %{
          "oneOf" => [
            %{
              "data" => %{
                "$ref" => "#/definitions/#{Ash.type(resource)}"
              }
            },
            %{
              "$ref" => "#/definitions/errors"
            }
          ]
        }
    end
  end

  defp route_href(route, api) do
    Path.join(AshJsonApi.prefix(api) || "", route.route)
  end
end
